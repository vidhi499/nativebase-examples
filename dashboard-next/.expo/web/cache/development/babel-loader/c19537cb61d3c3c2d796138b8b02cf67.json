{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.usePropsConfig = usePropsConfig;\n\nvar _lodash = require(\"lodash\");\n\nvar _reactNative = require(\"react-native-web/dist/index\");\n\nvar _useNativeBase = require(\"./useNativeBase\");\n\nvar _base = require(\"./../theme/base\");\n\nvar _tools = require(\"./../theme/tools/\");\n\nvar _filterShadowProps = require(\"./../utils/filterShadowProps\");\n\nfunction usePropsConfig(component, propsReceived) {\n  var _useWindowDimensions;\n\n  var _ref = (0, _useNativeBase.useNativeBase)(),\n      theme = _ref.theme,\n      colorModeProps = _objectWithoutProperties(_ref, [\"theme\"]);\n\n  var windowWidth = (_useWindowDimensions = (0, _reactNative.useWindowDimensions)()) === null || _useWindowDimensions === void 0 ? void 0 : _useWindowDimensions.width;\n  var currentBreakpoint = (0, _tools.getClosestBreakpoint)(theme.breakpoints, windowWidth);\n\n  if (!propsReceived) {\n    propsReceived = {};\n  }\n\n  var _ref2 = (0, _tools.extractInObject)(propsReceived, ['children', 'style']),\n      _ref3 = _slicedToArray(_ref2, 2),\n      ignoredProps = _ref3[0],\n      props = _ref3[1];\n\n  var componentTheme = (0, _lodash.get)(theme, \"components.\".concat(component));\n  props = (0, _tools.omitUndefined)(props);\n  var newProps;\n\n  if (componentTheme) {\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint);\n    var componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle(_objectSpread({\n      theme: theme\n    }, newProps, {}, props, {}, colorModeProps));\n    newProps = (0, _lodash.mergeWith)(newProps, componentBaseStyle, function (objValue, srcValue, key) {\n      if (!(0, _lodash.isNil)(objValue)) {\n        delete newProps[key];\n      }\n    });\n    var variant = props.variant || (0, _lodash.get)(componentTheme, 'defaultProps.variant');\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      var colorScheme = props.colorScheme || (0, _lodash.get)(componentTheme, 'defaultProps.colorScheme');\n      var variantProps = componentTheme.variants[variant](_objectSpread({}, props, {}, newProps, {\n        colorScheme: colorScheme,\n        theme: theme\n      }, colorModeProps));\n      newProps = (0, _lodash.mergeWith)(newProps, variantProps, function (objValue, srcValue, key) {\n        if (!(0, _lodash.isNil)(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n\n  var extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint);\n  newProps = (0, _lodash.mergeWith)(newProps, extractedProps, function (objValue, srcValue, key) {\n    if (!(0, _lodash.isNil)(objValue)) {\n      delete newProps[key];\n    }\n  });\n  var mergedProps = (0, _filterShadowProps.filterShadowProps)(newProps, ignoredProps);\n  return (0, _tools.omitUndefined)(mergedProps);\n}\n\nfunction extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint) {\n  var newProps = {};\n\n  for (var property in props) {\n    if (_base.themePropertyMap[property]) {\n      var propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!(0, _lodash.isNil)(propValues)) {\n        for (var nestedProp in propValues) {\n          newProps[nestedProp] = (0, _lodash.get)(theme, \"\".concat(_base.themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        var shadowProps = theme[_base.themePropertyMap[property]](colorModeProps)[props[property]];\n\n        if (!(0, _lodash.isNil)(shadowProps)) {\n          newProps = _objectSpread({}, newProps, {}, shadowProps);\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], currentBreakpoint, property);\n    }\n  }\n\n  return (0, _lodash.cloneDeep)(newProps);\n}\n\nfunction filterDefaultProps(props, defaultProps) {\n  var _ref4 = (0, _tools.extractInObject)(defaultProps, Object.keys(props)),\n      _ref5 = _slicedToArray(_ref4, 2),\n      resultProps = _ref5[1];\n\n  return resultProps;\n}\n\nvar extractPropertyFromFunction = function extractPropertyFromFunction(property, props, theme, componentTheme) {\n  var propValues;\n\n  if (componentTheme && typeof componentTheme[_base.themePropertyMap[property]] === 'function') {\n    var funcProps = componentTheme[_base.themePropertyMap[property]](_objectSpread({\n      theme: theme\n    }, props));\n\n    var isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    propValues = isNested ? _objectSpread({}, (0, _lodash.get)(funcProps, \"\".concat(props[property]))) : _objectSpread({}, funcProps);\n  } else {\n    propValues = (0, _lodash.get)(componentTheme, \"\".concat(_base.themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n\nvar resolveValueWithBreakpoint = function resolveValueWithBreakpoint(values, currentBreakpoint, property) {\n  if ((0, _tools.hasValidBreakpointFormat)(values, property)) {\n    return (0, _tools.findLastValidBreakpoint)(values, currentBreakpoint);\n  } else {\n    return values;\n  }\n};","map":{"version":3,"sources":["usePropsConfig.ts"],"names":["colorModeProps","windowWidth","currentBreakpoint","theme","propsReceived","componentTheme","props","newProps","extractProps","filterDefaultProps","componentBaseStyle","variant","colorScheme","variantProps","extractedProps","mergedProps","themePropertyMap","propValues","extractPropertyFromFunction","property","shadowProps","resolveValueWithBreakpoint","Object","funcProps","isNested"],"mappings":"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","sourcesContent":["import { get, isNil, mergeWith, cloneDeep } from 'lodash';\nimport { useWindowDimensions } from 'react-native';\nimport { useNativeBase } from './useNativeBase';\nimport { themePropertyMap } from './../theme/base';\nimport {\n  omitUndefined,\n  getClosestBreakpoint,\n  findLastValidBreakpoint,\n  hasValidBreakpointFormat,\n  extractInObject,\n} from './../theme/tools/';\nimport { filterShadowProps } from './../utils/filterShadowProps';\nexport function usePropsConfig(component: string, propsReceived: any) {\n  const { theme, ...colorModeProps } = useNativeBase();\n  let windowWidth = useWindowDimensions()?.width;\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n  if (!propsReceived) {\n    propsReceived = {};\n  }\n\n  // Extracting out children and style, as they do not contribute in props calculation\n  let [ignoredProps, props] = extractInObject(propsReceived, [\n    'children',\n    'style',\n  ]);\n  const componentTheme = get(theme, `components.${component}`);\n  props = omitUndefined(props);\n  let newProps: any;\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(\n      filterDefaultProps(props, componentTheme.defaultProps),\n      theme,\n      colorModeProps,\n      componentTheme,\n      currentBreakpoint\n    );\n    // Extracting props from base style\n    let componentBaseStyle =\n      typeof componentTheme.baseStyle !== 'function'\n        ? componentTheme.baseStyle\n        : componentTheme.baseStyle({\n            theme,\n            ...newProps,\n            ...props,\n            ...colorModeProps,\n          });\n    newProps = mergeWith(\n      newProps,\n      componentBaseStyle,\n      // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      }\n    );\n    const variant =\n      props.variant || get(componentTheme, 'defaultProps.variant');\n    // Extracting props from variant\n    if (\n      variant &&\n      componentTheme.variants &&\n      componentTheme.variants[variant]\n    ) {\n      const colorScheme =\n        props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({\n        ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps,\n      });\n      // added this to handle order of props\n      newProps = mergeWith(\n        newProps,\n        variantProps,\n        // @ts-ignore\n        (objValue, srcValue, key) => {\n          if (!isNil(objValue)) {\n            delete newProps[key];\n          }\n        }\n      );\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n\n  // Extracting props from normal props\n  let extractedProps = extractProps(\n    props,\n    theme,\n    colorModeProps,\n    componentTheme,\n    currentBreakpoint\n  );\n\n  // added this to handle order of props\n  // @ts-ignore\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  let mergedProps = filterShadowProps(newProps, ignoredProps);\n  return omitUndefined(mergedProps);\n}\n\n/*\n Extract props from theme props and omit those from props\n*/\nfunction extractProps(\n  props: any,\n  theme: any,\n  colorModeProps: any,\n  componentTheme: any,\n  currentBreakpoint: number\n) {\n  let newProps: any = {};\n  for (let property in props) {\n    // If the property exists in theme map then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(\n        property,\n        props,\n        theme,\n        componentTheme\n      );\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(\n            theme,\n            `${themePropertyMap[nestedProp]}.${propValues[nestedProp]}`,\n            propValues[nestedProp]\n          );\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]](colorModeProps)[\n          props[property]\n        ];\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps, ...shadowProps };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(\n          props[property],\n          currentBreakpoint,\n          property\n        );\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(\n        props[property],\n        currentBreakpoint,\n        property\n      );\n    }\n  }\n  return cloneDeep(newProps);\n}\n\n/*\nRemove props from defaultProps that are already present in props\n*/\nfunction filterDefaultProps(props: any, defaultProps: any) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n\n/*\nIf property is functional in componentTheme, get its returned object\n*/\nconst extractPropertyFromFunction = (\n  property: string,\n  props: any,\n  theme: any,\n  componentTheme: any\n) => {\n  let propValues;\n  if (\n    componentTheme &&\n    typeof componentTheme[themePropertyMap[property]] === 'function'\n  ) {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props,\n    });\n    // Check if returned object from componentTheme is a nested object\n    let isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    propValues = isNested\n      ? { ...get(funcProps, `${props[property]}`) }\n      : { ...funcProps };\n  } else {\n    propValues = get(\n      componentTheme,\n      `${themePropertyMap[property]}.${props[property]}`\n    );\n  }\n  return propValues;\n};\n\n/*\nChecks the property and resolves it if it has breakpoints\n*/\nconst resolveValueWithBreakpoint = (\n  values: any,\n  currentBreakpoint: number,\n  property: any\n) => {\n  if (hasValidBreakpointFormat(values, property)) {\n    return findLastValidBreakpoint(values, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}