{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.omitUndefined = omitUndefined;\nexports.extractInObject = extractInObject;\nexports.getColorFormColorScheme = getColorFormColorScheme;\nexports.getColorScheme = getColorScheme;\nexports.hasValidBreakpointFormat = hasValidBreakpointFormat;\nexports.findLastValidBreakpoint = findLastValidBreakpoint;\nexports.getClosestBreakpoint = getClosestBreakpoint;\nexports.inValidBreakpointProps = exports.breakpoints = void 0;\n\nvar _lodash = require(\"lodash\");\n\nfunction omitUndefined(obj) {\n  return (0, _lodash.omitBy)(obj, _lodash.isNil);\n}\n\nfunction extractInObject(parent, values) {\n  return [omitUndefined((0, _lodash.pick)(parent, values)), omitUndefined((0, _lodash.omit)(parent, values))];\n}\n\nfunction getColorFormColorScheme(props) {\n  var theme = props.theme,\n      colorScheme = props.colorScheme,\n      isDisabled = props.isDisabled;\n  var simpleColorScheme = colorScheme.split('.')[0];\n  if (isDisabled) return 'gray.300';else if (simpleColorScheme in theme.colors) {\n    return theme.colors[simpleColorScheme][0] === '#' ? simpleColorScheme : theme.colors[simpleColorScheme][400] || theme.colors[simpleColorScheme][200];\n  } else return 'default.200';\n}\n\nfunction getColorScheme(props, customColorScheme) {\n  var theme = props.theme,\n      colorScheme = props.colorScheme;\n  colorScheme = customColorScheme || colorScheme;\n  if (!(colorScheme in theme.colors)) return 'default';else {\n    if (typeof theme.colors[colorScheme] === 'object') return colorScheme;\n  }\n}\n\nvar breakpoints = Object.freeze(['base', 'sm', 'md', 'lg', 'xl']);\nexports.breakpoints = breakpoints;\nvar inValidBreakpointProps = ['style', 'children', 'shadowOffset'];\nexports.inValidBreakpointProps = inValidBreakpointProps;\n\nfunction hasValidBreakpointFormat(breaks, property) {\n  if (property && inValidBreakpointProps.indexOf(property) !== -1) {\n    return false;\n  } else if (Array.isArray(breaks)) {\n    return true;\n  } else if (typeof breaks === 'object') {\n    var keys = Object.keys(breaks);\n\n    for (var i = 0; i < keys.length; i++) {\n      if (breakpoints.indexOf(keys[i]) === -1) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction findLastValidBreakpoint(values, currentBreakpoint) {\n  var _valArray$currentBrea;\n\n  var valArray = Array.isArray(values) ? values : breakpoints.map(function (bPoint) {\n    return values[bPoint];\n  });\n  return (_valArray$currentBrea = valArray[currentBreakpoint]) !== null && _valArray$currentBrea !== void 0 ? _valArray$currentBrea : valArray.slice(0, currentBreakpoint + 1).filter(function (v) {\n    return v !== null && v !== void 0 ? v : null;\n  }).pop();\n}\n\nfunction getClosestBreakpoint(values, point) {\n  var dimValues = Object.values(values);\n  var index = -1;\n\n  for (var i = 0; i < dimValues.length; i++) {\n    if (dimValues[i] === point) {\n      index = i;\n      break;\n    } else if (dimValues[i] > point && i !== 0) {\n      index = i - 1;\n      break;\n    }\n  }\n\n  return index;\n}","map":{"version":3,"sources":["utils.ts"],"names":["isNil","omitUndefined","isDisabled","simpleColorScheme","colorScheme","theme","customColorScheme","breakpoints","Object","inValidBreakpointProps","property","Array","keys","i","valArray","bPoint","values","currentBreakpoint","v","dimValues","index"],"mappings":"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","sourcesContent":["import { omitBy, isNil, pick, omit } from 'lodash';\n\nexport type Dict = Record<string, any>;\n\nexport function omitUndefined(obj: any) {\n  return omitBy(obj, isNil);\n}\n\nexport function extractInObject(parent: any, values: Array<string>) {\n  return [\n    omitUndefined(pick(parent, values)),\n    omitUndefined(omit(parent, values)),\n  ];\n}\n\nexport function getColorFormColorScheme(props: Record<string, any>) {\n  const { theme, colorScheme, isDisabled } = props;\n  const simpleColorScheme = colorScheme.split('.')[0];\n\n  if (isDisabled) return 'gray.300';\n  else if (simpleColorScheme in theme.colors) {\n    return theme.colors[simpleColorScheme][0] === '#'\n      ? simpleColorScheme\n      : theme.colors[simpleColorScheme][400] ||\n          theme.colors[simpleColorScheme][200];\n  } else return 'default.200';\n}\nexport function getColorScheme(\n  props: Record<string, any>,\n  customColorScheme?: string\n) {\n  let { theme, colorScheme } = props;\n  colorScheme = customColorScheme || colorScheme;\n  if (!(colorScheme in theme.colors)) return 'default';\n  else {\n    if (typeof theme.colors[colorScheme] === 'object') return colorScheme;\n  }\n}\n\nexport const breakpoints = Object.freeze(['base', 'sm', 'md', 'lg', 'xl']);\nexport const inValidBreakpointProps = ['style', 'children', 'shadowOffset'];\n\nexport function hasValidBreakpointFormat(breaks: any, property?: string) {\n  if (property && inValidBreakpointProps.indexOf(property) !== -1) {\n    return false;\n  } else if (Array.isArray(breaks)) {\n    return true;\n  } else if (typeof breaks === 'object') {\n    const keys = Object.keys(breaks);\n    for (let i = 0; i < keys.length; i++) {\n      if (breakpoints.indexOf(keys[i]) === -1) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function findLastValidBreakpoint(\n  values: any,\n  currentBreakpoint: number\n) {\n  let valArray = Array.isArray(values)\n    ? values\n    : breakpoints.map((bPoint: string) => values[bPoint]);\n  return (\n    valArray[currentBreakpoint] ??\n    valArray\n      .slice(0, currentBreakpoint + 1)\n      .filter((v: any) => v ?? null)\n      .pop()\n  );\n}\n\nexport function getClosestBreakpoint(\n  values: Record<string, any>,\n  point: number\n) {\n  let dimValues = Object.values(values);\n  let index = -1;\n  for (let i = 0; i < dimValues.length; i++) {\n    if (dimValues[i] === point) {\n      index = i;\n      break;\n    } else if (dimValues[i] > point && i !== 0) {\n      index = i - 1;\n      break;\n    }\n  }\n  return index;\n}\n"]},"metadata":{},"sourceType":"script"}